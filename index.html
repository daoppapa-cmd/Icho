<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khmer Walkie Talkie (Final No Echo)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1",
        "firebase/app": "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js",
        "firebase/database": "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js"
      }
    }
    </script>
    
    <style>
        body {
            background-color: #171717;
            color: white;
            font-family: 'Noto Sans Khmer', sans-serif;
            overscroll-behavior: none;
        }
        ::-webkit-scrollbar {
            display: none;
        }
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        /* Modal Animation */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }
        .modal-animate {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { initializeApp } from 'firebase/app';
        import { 
            getDatabase, 
            ref, 
            set, 
            update, 
            push,
            onValue, 
            onChildAdded,
            remove,
            onDisconnect,
            query,
            limitToLast,
            serverTimestamp 
        } from 'firebase/database';
        import { Mic, Radio, Power, Users, Signal, UserPlus, Lock } from 'lucide-react';

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAcfDALTjrGiD_Te5DyFp7x-F6NrPwqEr4",
            authDomain: "icho-7ddb4.firebaseapp.com",
            databaseURL: "https://icho-7ddb4-default-rtdb.firebaseio.com", 
            projectId: "icho-7ddb4",
            storageBucket: "icho-7ddb4.firebasestorage.app",
            messagingSenderId: "897027326100",
            appId: "1:897027326100:web:a5d726c168a3fc01d23481",
            measurementId: "G-0LPCL7ETRF"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- Constants ---
        const SAMPLE_RATE = 11025; 
        const JITTER_BUFFER_MS = 150; 

        // --- Main App Component ---
        function App() {
            // User & System State
            const [userId, setUserId] = useState(null);
            const [userName, setUserName] = useState('');
            const [isNameSet, setIsNameSet] = useState(false);
            const [tempName, setTempName] = useState('');
            
            // Walkie Talkie State
            const [powerOn, setPowerOn] = useState(false);
            const [currentChannel, setCurrentChannel] = useState('01');
            const [isTransmitting, setIsTransmitting] = useState(false);
            const [incomingTransmission, setIncomingTransmission] = useState(null); 
            const [onlineCount, setOnlineCount] = useState(0);

            // Audio Refs
            const audioContextRef = useRef(null);
            const analyserRef = useRef(null);
            const isTransmittingRef = useRef(false);
            
            const canvasRef = useRef(null);
            const processorRef = useRef(null);
            const streamRef = useRef(null);
            const requestRef = useRef(null);
            const nextStartTimeRef = useRef(0);

            // --- 1. Initialization & Name Handling ---
            useEffect(() => {
                // Check LocalStorage for ID
                let storedId = localStorage.getItem('walkie_user_id');
                if (!storedId) {
                    storedId = 'user_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('walkie_user_id', storedId);
                }
                setUserId(storedId);

                // Check LocalStorage for Name
                const storedName = localStorage.getItem('walkie_user_name');
                if (storedName) {
                    setUserName(storedName);
                    setIsNameSet(true);
                }
            }, []);

            const handleNameSubmit = (e) => {
                e.preventDefault();
                if (tempName.trim().length > 0) {
                    const finalName = tempName.trim();
                    localStorage.setItem('walkie_user_name', finalName);
                    setUserName(finalName);
                    setIsNameSet(true);
                }
            };

            // --- 2. Presence System (Online/Offline) ---
            useEffect(() => {
                if (!userId || !userName) return;

                // Reference to this user's presence on the current channel
                const userPresenceRef = ref(db, `channels/channel_${currentChannel}/users/${userId}`);

                if (powerOn) {
                    // Set Online
                    set(userPresenceRef, {
                        name: userName,
                        status: 'online',
                        lastSeen: serverTimestamp()
                    });
                    
                    // Auto remove on disconnect (close browser/tab)
                    onDisconnect(userPresenceRef).remove();
                } else {
                    // Remove from list when Power Off
                    remove(userPresenceRef);
                    // Cancel onDisconnect since we removed it manually
                    onDisconnect(userPresenceRef).cancel();
                }

                // Cleanup on unmount or channel change
                return () => {
                    if (powerOn) {
                         remove(userPresenceRef);
                    }
                };
            }, [powerOn, userId, userName, currentChannel]);

            // --- 3. Active Users Listener ---
            useEffect(() => {
                const usersRef = ref(db, `channels/channel_${currentChannel}/users`);
                
                const unsubscribe = onValue(usersRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const users = snapshot.val();
                        // Count how many users are in the list
                        const count = Object.keys(users).length;
                        setOnlineCount(count);
                    } else {
                        setOnlineCount(0);
                    }
                });

                return () => unsubscribe();
            }, [currentChannel]);

            // --- 4. Incoming Transmission Status Listener ---
            useEffect(() => {
                if (!userId || !powerOn) return;

                const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                
                const unsubscribe = onValue(statusRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data && data.isActive && data.userId !== userId) {
                        setIncomingTransmission({
                            userId: data.userId,
                            userName: data.userName || 'Unknown'
                        });
                    } else {
                        setIncomingTransmission(null);
                    }
                });

                return () => unsubscribe();
            }, [userId, powerOn, currentChannel]);

            // --- 5. Audio Data Listener ---
            useEffect(() => {
                if (!userId || !powerOn) return;

                const audioRef = ref(db, `channels/channel_${currentChannel}/audio_stream`);
                const recentQuery = query(audioRef, limitToLast(1)); 
                
                const unsubscribe = onChildAdded(recentQuery, (snapshot) => {
                    const data = snapshot.val();
                    if (isTransmittingRef.current) return;

                    if (data && data.userId !== userId && data.pcmData) {
                         playPCMChunk(data.pcmData);
                    }
                });

                return () => unsubscribe();
            }, [userId, powerOn, currentChannel]);

            // --- Audio Logic (Play & Record) ---
            const playPCMChunk = async (base64Data) => {
                const ctx = audioContextRef.current;
                if (!ctx) return;

                if (ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch(e) {}
                }

                try {
                    const binaryString = window.atob(base64Data);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const int16Data = new Int16Array(bytes.buffer);
                    const float32Data = new Float32Array(int16Data.length);
                    for (let i = 0; i < int16Data.length; i++) {
                        float32Data[i] = int16Data[i] / 32768.0;
                    }

                    const buffer = ctx.createBuffer(1, float32Data.length, SAMPLE_RATE);
                    buffer.copyToChannel(float32Data, 0);

                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);

                    const currentTime = ctx.currentTime;
                    const bufferSec = JITTER_BUFFER_MS / 1000;
                    
                    if (nextStartTimeRef.current < currentTime) {
                        nextStartTimeRef.current = currentTime + bufferSec; 
                    }

                    source.start(nextStartTimeRef.current);
                    nextStartTimeRef.current += buffer.duration;
                } catch (err) {
                    console.error("Error playing PCM:", err);
                }
            };

            const animate = () => {
                if (!canvasRef.current || !analyserRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const analyser = analyserRef.current;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = '#1f2937'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let barHeight;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i] / 2;
                    ctx.fillStyle = `rgb(50, ${barHeight + 100}, 50)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }

                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                if (isTransmitting && powerOn) {
                    requestRef.current = requestAnimationFrame(animate);
                } else {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                    if (canvasRef.current) {
                        const ctx = canvasRef.current.getContext('2d');
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                        ctx.strokeStyle = '#374151';
                        ctx.beginPath();
                        ctx.moveTo(0, canvasRef.current.height / 2);
                        ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);
                        ctx.stroke();
                    }
                }
                return () => {
                     if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, [isTransmitting, powerOn]);

            const startTransmission = async (e) => {
                if(e) e.preventDefault();
                
                // --- Active User Check Constraint ---
                // If only 1 user (me) is online, prevent transmission
                if (onlineCount <= 1) {
                    alert("គ្មានអ្នកផ្សេង Online ទេ។ សូមរង់ចាំ...");
                    return;
                }
                
                if (!powerOn || !userId || incomingTransmission) return;

                try {
                    const ctx = audioContextRef.current;
                    if (ctx && ctx.state === 'suspended') {
                        await ctx.resume();
                    }

                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            googEchoCancellation: true,
                            googAutoGainControl: true,
                            googNoiseSuppression: true,
                            googHighpassFilter: true
                        } 
                    });
                    streamRef.current = stream;
                    
                    const source = ctx.createMediaStreamSource(stream);
                    
                    if (analyserRef.current) {
                        source.connect(analyserRef.current);
                    }

                    const processor = ctx.createScriptProcessor(4096, 1, 1);
                    processorRef.current = processor;

                    const dummyDest = ctx.createMediaStreamDestination();
                    source.connect(processor);
                    processor.connect(dummyDest); 

                    processor.onaudioprocess = (e) => {
                        if (!streamRef.current) return;
                        const inputData = e.inputBuffer.getChannelData(0);
                        const inputRate = ctx.sampleRate;
                        const ratio = inputRate / SAMPLE_RATE;
                        const downsampledLength = Math.ceil(inputData.length / ratio);
                        const int16Buffer = new Int16Array(downsampledLength);
                        
                        let offset = 0;
                        for (let i = 0; i < inputData.length; i += ratio) {
                            const idx = Math.floor(i);
                            if (idx >= inputData.length) break;
                            let s = Math.max(-1, Math.min(1, inputData[idx]));
                            int16Buffer[offset++] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        let binary = '';
                        const bytes = new Uint8Array(int16Buffer.buffer);
                        const len = bytes.byteLength;
                        for (let i = 0; i < len; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        const base64data = window.btoa(binary);

                        const audioRef = ref(db, `channels/channel_${currentChannel}/audio_stream`);
                        push(audioRef, {
                            userId: userId,
                            pcmData: base64data,
                        });
                    };

                    setIsTransmitting(true);
                    isTransmittingRef.current = true;
                    
                    const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                    onDisconnect(statusRef).update({ isActive: false });
                    await set(statusRef, {
                        isActive: true,
                        userId: userId,
                        userName: userName
                    });

                    const audioRef = ref(db, `channels/channel_${currentChannel}/audio_stream`);
                    remove(audioRef);

                    playBeep(600, 0.1);

                } catch (err) {
                    console.error("Error accessing mic:", err);
                    alert("សូមអនុញ្ញាតឱ្យប្រើប្រាស់មីក្រូហ្វូន");
                    setIsTransmitting(false);
                    isTransmittingRef.current = false;
                }
            };

            const stopTransmission = async (e) => {
                if(e) e.preventDefault();
                if (!isTransmitting) return;

                if (processorRef.current) {
                    processorRef.current.disconnect();
                    processorRef.current.onaudioprocess = null;
                    processorRef.current = null;
                }

                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                    streamRef.current = null;
                }

                setIsTransmitting(false);
                isTransmittingRef.current = false;
                playBeep(400, 0.1);

                const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                onDisconnect(statusRef).cancel();
                await update(statusRef, { isActive: false });
            };

            const playBeep = (freq, duration) => {
                const ctx = audioContextRef.current;
                if (!ctx) return;
                try {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    osc.start();
                    osc.stop(ctx.currentTime + duration);
                } catch(e) {}
            };

            const handleChannelChange = (delta) => {
                if (!powerOn) return;
                let newCh = parseInt(currentChannel) + delta;
                if (newCh < 1) newCh = 1;
                if (newCh > 99) newCh = 99;
                setCurrentChannel(newCh.toString().padStart(2, '0'));
                playBeep(800, 0.05);
            };

            const togglePower = async (e) => {
                e.stopPropagation();
                
                if (!powerOn) {
                    // Turn ON
                    if (!audioContextRef.current) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        const ctx = new AudioContext();
                        audioContextRef.current = ctx;
                        const anal = ctx.createAnalyser();
                        anal.fftSize = 256;
                        analyserRef.current = anal;
                        nextStartTimeRef.current = ctx.currentTime;
                    } else if (audioContextRef.current.state === 'suspended') {
                        await audioContextRef.current.resume();
                    }
                    
                    setPowerOn(true);
                    setTimeout(() => playBeep(1000, 0.2), 500);
                } else {
                    // Turn OFF
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(track => track.stop());
                        streamRef.current = null;
                    }
                    if (processorRef.current) {
                        processorRef.current.disconnect();
                        processorRef.current = null;
                    }
                    setPowerOn(false);
                    isTransmittingRef.current = false;
                    setIsTransmitting(false);
                    setOnlineCount(0); // Reset count view locally
                }
            };

            // --- UI: Name Input Modal ---
            if (!isNameSet) {
                return (
                    <div className="min-h-screen bg-neutral-900 flex items-center justify-center p-4 font-sans text-white">
                        <div className="bg-neutral-800 p-8 rounded-3xl border-2 border-neutral-700 w-full max-w-md modal-animate shadow-2xl">
                            <div className="flex justify-center mb-6">
                                <div className="p-4 bg-orange-600 rounded-full shadow-[0_0_20px_rgba(234,88,12,0.3)]">
                                    <Radio size={48} className="text-white" />
                                </div>
                            </div>
                            <h2 className="text-2xl font-bold text-center mb-2">បញ្ចូលឈ្មោះរបស់អ្នក</h2>
                            <p className="text-center text-neutral-400 mb-6 text-sm">សូមដាក់ឈ្មោះដើម្បីឱ្យអ្នកផ្សេងស្គាល់ (Realtime Radio)</p>
                            
                            <form onSubmit={handleNameSubmit} className="flex flex-col gap-4">
                                <input 
                                    type="text" 
                                    value={tempName}
                                    onChange={(e) => setTempName(e.target.value)}
                                    placeholder="ឈ្មោះរបស់អ្នក..."
                                    className="p-4 rounded-xl bg-neutral-900 border border-neutral-700 text-white placeholder-neutral-500 focus:outline-none focus:border-orange-500 text-center text-lg"
                                    autoFocus
                                    maxLength={15}
                                />
                                <button 
                                    type="submit" 
                                    disabled={!tempName.trim()}
                                    className="p-4 rounded-xl bg-orange-600 font-bold text-lg disabled:opacity-50 disabled:cursor-not-allowed hover:bg-orange-500 transition-colors shadow-lg"
                                >
                                    ចាប់ផ្តើម
                                </button>
                            </form>
                        </div>
                    </div>
                );
            }

            // --- Render Main App ---
            const isAlone = onlineCount <= 1;

            return (
                <div className="min-h-screen bg-neutral-900 flex items-center justify-center p-4 font-sans no-select overflow-hidden touch-none">
                    <div className="relative w-full max-w-sm bg-neutral-800 rounded-[3rem] shadow-2xl border-4 border-neutral-700 flex flex-col overflow-hidden">
                        
                        {/* Antenna */}
                        <div className="absolute -top-16 right-8 w-6 h-24 bg-neutral-700 rounded-t-lg border-2 border-neutral-600 z-0"></div>
                        <div className="absolute -top-4 left-8 w-3 h-6 bg-red-600 rounded-sm z-0 animate-pulse"></div>

                        {/* Speaker Grille */}
                        <div className="mt-8 mx-auto w-3/4 grid grid-cols-6 gap-1 z-10 opacity-50">
                        {[...Array(24)].map((_, i) => (
                            <div key={i} className="w-1.5 h-1.5 bg-black rounded-full"></div>
                        ))}
                        </div>

                        {/* LCD Screen */}
                        <div className="mx-6 mt-6 bg-[#9ea792] p-4 rounded-md shadow-inner border-4 border-neutral-600 relative overflow-hidden">
                            <div className="absolute inset-0 bg-green-900 opacity-10 pointer-events-none grid grid-cols-12 gap-px"></div>
                            
                            {powerOn ? (
                                <div className="relative z-10 flex flex-col h-32 justify-between">
                                    <div className="flex justify-between items-center text-xs font-mono font-bold text-neutral-800">
                                        <div className="flex items-center gap-1">
                                            <Signal size={14} />
                                            <span>ON: {onlineCount}</span>
                                        </div>
                                        <div className="flex items-center gap-1">
                                            <Users size={14} />
                                            <span>CH {currentChannel}</span>
                                        </div>
                                    </div>

                                    <div className="text-center">
                                        {isTransmitting ? (
                                            <div className="text-red-700 font-bold text-lg animate-pulse flex flex-col items-center">
                                                <span>TRANSMITTING</span>
                                                <span className="text-xs mt-1">{userName}</span>
                                            </div>
                                        ) : incomingTransmission ? (
                                            <div className="text-green-800 font-bold text-lg flex flex-col items-center">
                                                <span>RECEIVING</span>
                                                <span className="text-sm truncate max-w-full">{String(incomingTransmission.userName)}</span>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center">
                                                <div className="text-neutral-600 text-lg font-mono">STANDBY</div>
                                                <div className="text-neutral-500 text-xs mt-1 font-mono">{userName}</div>
                                            </div>
                                        )}
                                    </div>

                                    <div className="text-4xl font-black font-mono text-center tracking-widest text-neutral-800 opacity-80">
                                        {currentChannel}
                                    </div>
                                </div>
                            ) : (
                                <div className="h-32 flex items-center justify-center flex-col text-neutral-400 font-mono text-sm opacity-50">
                                    <span>POWER OFF</span>
                                    <span className="text-xs mt-2 text-neutral-500">({userName})</span>
                                </div>
                            )}
                        </div>

                        {/* Controls */}
                        <div className="p-6 flex flex-col gap-6 z-10 bg-neutral-800">
                            
                            <div className="h-16 bg-gray-900 rounded-lg border border-gray-700 overflow-hidden relative shadow-inner">
                                <canvas 
                                    ref={canvasRef} 
                                    width="300" 
                                    height="64" 
                                    className="w-full h-full opacity-80"
                                />
                                <div className="absolute top-1 left-2 text-[10px] text-green-500 font-mono">AUDIO LEVEL</div>
                            </div>

                            <div className="flex justify-between items-center px-2">
                                <button 
                                    onClick={togglePower}
                                    className={`p-4 rounded-full border-b-4 active:border-b-0 active:translate-y-1 transition-all ${powerOn ? 'bg-green-600 border-green-800 text-white shadow-[0_0_15px_rgba(34,197,94,0.5)]' : 'bg-red-600 border-red-800 text-white'}`}
                                >
                                    <Power size={24} />
                                </button>

                                <div className="flex flex-col items-center gap-2 bg-neutral-900 p-2 rounded-xl border border-neutral-700">
                                    <span className="text-[10px] text-gray-400 uppercase tracking-wider">Channel</span>
                                    <div className="flex items-center gap-3">
                                        <button 
                                            disabled={!powerOn}
                                            onClick={() => handleChannelChange(-1)}
                                            className="w-10 h-10 bg-neutral-700 rounded-lg flex items-center justify-center active:bg-neutral-600 disabled:opacity-50 text-white"
                                        >
                                            -
                                        </button>
                                        <span className="text-green-500 font-mono text-xl w-6 text-center">{currentChannel}</span>
                                        <button 
                                            disabled={!powerOn}
                                            onClick={() => handleChannelChange(1)}
                                            className="w-10 h-10 bg-neutral-700 rounded-lg flex items-center justify-center active:bg-neutral-600 disabled:opacity-50 text-white"
                                        >
                                            +
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="relative group">
                                <button
                                    disabled={!powerOn || isAlone}
                                    onMouseDown={startTransmission}
                                    onMouseUp={stopTransmission}
                                    onMouseLeave={stopTransmission}
                                    onTouchStart={startTransmission}
                                    onTouchEnd={stopTransmission}
                                    className={`
                                        w-full py-8 rounded-2xl font-bold text-xl tracking-widest text-white shadow-lg transition-all
                                        border-b-8 active:border-b-0 active:translate-y-2 select-none
                                        flex items-center justify-center gap-3
                                        ${powerOn 
                                            ? isAlone
                                                ? 'bg-neutral-600 border-neutral-700 cursor-not-allowed opacity-70' 
                                                : 'bg-orange-600 border-orange-800 hover:bg-orange-500 cursor-pointer' 
                                            : 'bg-neutral-600 border-neutral-700 cursor-not-allowed opacity-50'}
                                    `}
                                >
                                    {isAlone && powerOn ? (
                                        <>
                                            <Lock size={20} className="text-neutral-400" />
                                            <span className="text-sm">WAITING FOR USERS...</span>
                                        </>
                                    ) : (
                                        <>
                                            <Mic className={`${isTransmitting ? 'animate-pulse' : ''}`} />
                                            <span>{isTransmitting ? 'TRANSMITTING' : 'PUSH TO TALK'}</span>
                                        </>
                                    )}
                                </button>
                                
                                <div className="absolute inset-0 pointer-events-none opacity-10 bg-[url('https://www.transparenttextures.com/patterns/diagmonds-light.png')]"></div>
                            </div>

                            <div className="mt-2 text-center">
                                {isAlone && powerOn && (
                                    <p className="text-yellow-500 text-xs animate-pulse">កំពុងរង់ចាំអ្នកផ្សេង Online...</p>
                                )}
                            </div>
                        </div>

                        <div className="absolute bottom-4 left-4 w-3 h-3 rounded-full bg-neutral-900 border border-neutral-600 flex items-center justify-center">
                            <div className="w-full h-0.5 bg-neutral-700 rotate-45"></div>
                        </div>
                        <div className="absolute bottom-4 right-4 w-3 h-3 rounded-full bg-neutral-900 border border-neutral-600 flex items-center justify-center">
                            <div className="w-full h-0.5 bg-neutral-700 rotate-45"></div>
                        </div>
                    </div>

                    <div className="fixed bottom-4 flex flex-col items-center gap-1 text-neutral-500 text-xs">
                        <p>ចុចប៊ូតុង <span className="text-orange-500 font-bold">PUSH TO TALK</span> ឲ្យជាប់ដើម្បីនិយាយ</p>
                        <div className="flex items-center gap-1">
                            <span>ត្រូវប្រាកដថាបានបើក</span>
                            <Power size={12} className="text-green-500"/>
                            <span>ជាមុនសិន</span>
                        </div>
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
