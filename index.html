<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khmer Walkie Talkie (Pro Audio)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1",
        "firebase/app": "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js",
        "firebase/database": "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js"
      }
    }
    </script>
    
    <style>
        body {
            background-color: #171717;
            color: white;
            font-family: 'Noto Sans Khmer', sans-serif;
        }
        ::-webkit-scrollbar {
            display: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { initializeApp } from 'firebase/app';
        import { 
            getDatabase, 
            ref, 
            set, 
            update, 
            push,
            onValue, 
            onChildAdded,
            remove,
            onDisconnect,
            serverTimestamp 
        } from 'firebase/database';
        import { Mic, Radio, Power, Users, Signal } from 'lucide-react';

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAcfDALTjrGiD_Te5DyFp7x-F6NrPwqEr4",
            authDomain: "icho-7ddb4.firebaseapp.com",
            databaseURL: "https://icho-7ddb4-default-rtdb.firebaseio.com", 
            projectId: "icho-7ddb4",
            storageBucket: "icho-7ddb4.firebasestorage.app",
            messagingSenderId: "897027326100",
            appId: "1:897027326100:web:a5d726c168a3fc01d23481",
            measurementId: "G-0LPCL7ETRF"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- Main App Component ---
        function App() {
            const [userId, setUserId] = useState(null);
            const [powerOn, setPowerOn] = useState(false);
            const [currentChannel, setCurrentChannel] = useState('01');
            const [isTransmitting, setIsTransmitting] = useState(false);
            const [incomingTransmission, setIncomingTransmission] = useState(null); 
            const [audioContext, setAudioContext] = useState(null);
            const [analyser, setAnalyser] = useState(null);
            const [userName, setUserName] = useState('');
            
            const canvasRef = useRef(null);
            const requestRef = useRef(null);
            const mediaRecorderRef = useRef(null);
            const recordingIntervalRef = useRef(null);
            
            // Audio Scheduling Refs
            const nextStartTimeRef = useRef(0);
            const audioContextRef = useRef(null);
            const isPlayingRef = useRef(false);

            // --- Setup User ID ---
            useEffect(() => {
                let storedId = localStorage.getItem('walkie_user_id');
                if (!storedId) {
                    storedId = 'user_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('walkie_user_id', storedId);
                }
                setUserId(storedId);
                const randomNum = Math.floor(Math.random() * 1000);
                setUserName(`អ្នកប្រើប្រាស់ ${randomNum}`);
            }, []);

            // --- Incoming Status Listener ---
            useEffect(() => {
                if (!userId || !powerOn) return;

                const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                
                const unsubscribe = onValue(statusRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data && data.isActive && data.userId !== userId) {
                        const now = Date.now();
                        const lastActive = data.timestamp || 0;
                        
                        if (now - lastActive < 8000) {
                            setIncomingTransmission({
                                userId: data.userId,
                                userName: data.userName || 'Unknown'
                            });
                        } else {
                            setIncomingTransmission(null);
                        }
                    } else {
                        setIncomingTransmission(null);
                    }
                });

                return () => unsubscribe();
            }, [userId, powerOn, currentChannel]);

            // --- Audio Data Listener (RECEIVER) ---
            useEffect(() => {
                if (!userId || !powerOn) return;

                const audioRef = ref(db, `channels/channel_${currentChannel}/audio_chunks`);
                
                const unsubscribe = onChildAdded(audioRef, async (snapshot) => {
                    const data = snapshot.val();
                    
                    if (data && data.userId !== userId && data.audioData) {
                         const timeDiff = Date.now() - (data.timestamp || 0);
                         // Increase tolerance for slow networks
                         if (timeDiff < 15000) {
                             await scheduleAudioChunk(data.audioData);
                         }
                    }
                });

                return () => unsubscribe();
            }, [userId, powerOn, currentChannel]);

            // --- Audio Context Lifecycle ---
            useEffect(() => {
                if (powerOn) {
                    if (!audioContextRef.current) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        const ctx = new AudioContext();
                        audioContextRef.current = ctx;
                        
                        const anal = ctx.createAnalyser();
                        anal.fftSize = 256;
                        setAnalyser(anal);
                        setAudioContext(ctx);
                        
                        nextStartTimeRef.current = ctx.currentTime;
                    } else {
                        if (audioContextRef.current.state === 'suspended') {
                            audioContextRef.current.resume();
                        }
                    }
                } else {
                    if (audioContextRef.current) {
                        audioContextRef.current.close();
                        audioContextRef.current = null;
                        setAudioContext(null);
                        setAnalyser(null);
                    }
                }
            }, [powerOn]);

            // --- Helper: Schedule Audio Chunk (Seamless Playback) ---
            const scheduleAudioChunk = async (base64Data) => {
                const ctx = audioContextRef.current;
                if (!ctx) return;

                try {
                    // 1. Decode Base64
                    const binaryString = window.atob(base64Data.split(',')[1]);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const arrayBuffer = bytes.buffer;

                    // 2. Decode Audio Data (Now works because each chunk is a valid file)
                    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);

                    // 3. Schedule Playback
                    const source = ctx.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(ctx.destination);

                    // Ensure seamless playback
                    const currentTime = ctx.currentTime;
                    if (nextStartTimeRef.current < currentTime) {
                        nextStartTimeRef.current = currentTime + 0.05; // Small buffer for network jitter
                    }

                    source.start(nextStartTimeRef.current);
                    nextStartTimeRef.current += audioBuffer.duration;

                } catch (err) {
                    console.error("Error decoding audio:", err);
                    // If error persists, it usually means a corrupted chunk or codec mismatch
                }
            };

            // --- Visualizer Animation ---
            const animate = () => {
                if (!canvasRef.current || !analyser) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = '#1f2937'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let barHeight;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i] / 2;
                    ctx.fillStyle = `rgb(50, ${barHeight + 100}, 50)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }

                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                if (isTransmitting && analyser) {
                    requestRef.current = requestAnimationFrame(animate);
                } else {
                    cancelAnimationFrame(requestRef.current);
                    if (canvasRef.current) {
                        const ctx = canvasRef.current.getContext('2d');
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                        ctx.strokeStyle = '#374151';
                        ctx.beginPath();
                        ctx.moveTo(0, canvasRef.current.height / 2);
                        ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);
                        ctx.stroke();
                    }
                }
                return () => cancelAnimationFrame(requestRef.current);
            }, [isTransmitting, analyser]);

            // --- Recording Loop Logic ---
            const recordSegment = (stream) => {
                if (!isTransmitting) return;

                const options = { mimeType: 'audio/webm' }; 
                // Using standard webm, usually safer for simple chunking than codec specific
                
                const recorder = new MediaRecorder(stream, options);
                mediaRecorderRef.current = recorder;

                recorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) {
                        const reader = new FileReader();
                        reader.readAsDataURL(e.data);
                        reader.onloadend = () => {
                            const base64data = reader.result;
                            if (isTransmitting) { // Double check we are still transmitting
                                const audioRef = ref(db, `channels/channel_${currentChannel}/audio_chunks`);
                                push(audioRef, {
                                    userId: userId,
                                    audioData: base64data,
                                    timestamp: serverTimestamp()
                                });
                            }
                        };
                    }
                };

                recorder.start();
                // Stop and restart quickly to force a valid header on each chunk
                setTimeout(() => {
                    if (recorder.state === 'recording') {
                        recorder.stop();
                    }
                }, 500); // 500ms chunks
            };

            // --- Transmit Logic (SENDER - Chunking Fix) ---
            const startTransmission = async () => {
                if (!powerOn || !userId || incomingTransmission) return;

                try {
                    const ctx = audioContextRef.current;
                    if (ctx && ctx.state === 'suspended') {
                        await ctx.resume();
                    }

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    
                    // Connect to Visualizer
                    if (ctx && analyser) {
                        const source = ctx.createMediaStreamSource(stream);
                        source.connect(analyser);
                    }

                    setIsTransmitting(true);
                    
                    // Update Status
                    const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                    onDisconnect(statusRef).update({ isActive: false });
                    await set(statusRef, {
                        isActive: true,
                        userId: userId,
                        userName: userName,
                        timestamp: serverTimestamp()
                    });

                    // Clear old audio chunks
                    const audioRef = ref(db, `channels/channel_${currentChannel}/audio_chunks`);
                    remove(audioRef);

                    // Start Recording Loop
                    // We need a loop that restarts the recorder every X ms
                    // Using a recursive approach or interval
                    let isActive = true;
                    
                    const loop = () => {
                        if (!isActive) return;
                        recordSegment(stream);
                        // Schedule next segment slightly before previous ends to ensure overlap? 
                        // Actually just sequential is fine for this method.
                        setTimeout(loop, 550); // slight delay + buffer
                    };
                    
                    // We need to attach this state to ref to stop it later
                    recordingIntervalRef.current = { stop: () => { isActive = false; } };
                    
                    loop();

                    playBeep(600, 0.1);

                } catch (err) {
                    console.error("Error accessing mic:", err);
                    alert("សូមអនុញ្ញាតឱ្យប្រើប្រាស់មីក្រូហ្វូនដើម្បីនិយាយ");
                    setIsTransmitting(false);
                }
            };

            const stopTransmission = async () => {
                if (!isTransmitting) return;

                // Stop the loop
                if (recordingIntervalRef.current) {
                    recordingIntervalRef.current.stop();
                    recordingIntervalRef.current = null;
                }

                // Stop current recorder if active
                if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
                    mediaRecorderRef.current.stop();
                    // Stop stream tracks
                    mediaRecorderRef.current.stream.getTracks().forEach(track => track.stop());
                }

                setIsTransmitting(false);
                playBeep(400, 0.1);

                const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                onDisconnect(statusRef).cancel();
                await update(statusRef, { isActive: false });
            };

            // --- Helpers ---
            const playBeep = (freq, duration) => {
                const ctx = audioContextRef.current;
                if (!ctx) return;
                
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.value = freq;
                osc.type = 'square';
                gain.gain.setValueAtTime(0.1, ctx.currentTime);
                osc.start();
                osc.stop(ctx.currentTime + duration);
            };

            const handleChannelChange = (delta) => {
                if (!powerOn) return;
                let newCh = parseInt(currentChannel) + delta;
                if (newCh < 1) newCh = 1;
                if (newCh > 99) newCh = 99;
                setCurrentChannel(newCh.toString().padStart(2, '0'));
                playBeep(800, 0.05);
            };

            const togglePower = async () => {
                if (!powerOn) {
                    setPowerOn(true);
                    setTimeout(() => playBeep(1000, 0.2), 500);
                } else {
                    setPowerOn(false);
                    setIsTransmitting(false);
                }
            };

            // --- Render ---
            return (
                <div className="min-h-screen bg-neutral-900 flex items-center justify-center p-4 font-sans select-none overflow-hidden">
                    <div className="relative w-full max-w-sm bg-neutral-800 rounded-[3rem] shadow-2xl border-4 border-neutral-700 flex flex-col overflow-hidden">
                        
                        <div className="absolute -top-16 right-8 w-6 h-24 bg-neutral-700 rounded-t-lg border-2 border-neutral-600 z-0"></div>
                        <div className="absolute -top-4 left-8 w-3 h-6 bg-red-600 rounded-sm z-0 animate-pulse"></div>

                        <div className="mt-8 mx-auto w-3/4 grid grid-cols-6 gap-1 z-10 opacity-50">
                        {[...Array(24)].map((_, i) => (
                            <div key={i} className="w-1.5 h-1.5 bg-black rounded-full"></div>
                        ))}
                        </div>

                        <div className="mx-6 mt-6 bg-[#9ea792] p-4 rounded-md shadow-inner border-4 border-neutral-600 relative overflow-hidden">
                            <div className="absolute inset-0 bg-green-900 opacity-10 pointer-events-none grid grid-cols-12 gap-px"></div>
                            
                            {powerOn ? (
                                <div className="relative z-10 flex flex-col h-32 justify-between">
                                    <div className="flex justify-between items-center text-xs font-mono font-bold text-neutral-800">
                                        <div className="flex items-center gap-1">
                                            <Signal size={14} />
                                            <span>RX/TX</span>
                                        </div>
                                        <div className="flex items-center gap-1">
                                            <Users size={14} />
                                            <span>CH {currentChannel}</span>
                                        </div>
                                    </div>

                                    <div className="text-center">
                                        {isTransmitting ? (
                                            <div className="text-red-700 font-bold text-lg animate-pulse flex flex-col items-center">
                                                <span>TRANSMITTING</span>
                                                <span className="text-sm">កំពុងនិយាយ...</span>
                                            </div>
                                        ) : incomingTransmission ? (
                                            <div className="text-green-800 font-bold text-lg flex flex-col items-center">
                                                <span>RECEIVING</span>
                                                <span className="text-sm truncate max-w-full">{String(incomingTransmission.userName)}</span>
                                            </div>
                                        ) : (
                                            <div className="text-neutral-600 text-lg font-mono">STANDBY</div>
                                        )}
                                    </div>

                                    <div className="text-4xl font-black font-mono text-center tracking-widest text-neutral-800 opacity-80">
                                        {currentChannel}
                                    </div>
                                </div>
                            ) : (
                                <div className="h-32 flex items-center justify-center text-neutral-400 font-mono text-sm opacity-50">
                                    POWER OFF
                                </div>
                            )}
                        </div>

                        <div className="p-6 flex flex-col gap-6 z-10 bg-neutral-800">
                            
                            <div className="h-16 bg-gray-900 rounded-lg border border-gray-700 overflow-hidden relative shadow-inner">
                                <canvas 
                                    ref={canvasRef} 
                                    width="300" 
                                    height="64" 
                                    className="w-full h-full opacity-80"
                                />
                                <div className="absolute top-1 left-2 text-[10px] text-green-500 font-mono">AUDIO LEVEL</div>
                            </div>

                            <div className="flex justify-between items-center px-2">
                                <button 
                                    onClick={togglePower}
                                    className={`p-4 rounded-full border-b-4 active:border-b-0 active:translate-y-1 transition-all ${powerOn ? 'bg-green-600 border-green-800 text-white shadow-[0_0_15px_rgba(34,197,94,0.5)]' : 'bg-red-600 border-red-800 text-white'}`}
                                >
                                    <Power size={24} />
                                </button>

                                <div className="flex flex-col items-center gap-2 bg-neutral-900 p-2 rounded-xl border border-neutral-700">
                                    <span className="text-[10px] text-gray-400 uppercase tracking-wider">Channel</span>
                                    <div className="flex items-center gap-3">
                                        <button 
                                            disabled={!powerOn}
                                            onClick={() => handleChannelChange(-1)}
                                            className="w-10 h-10 bg-neutral-700 rounded-lg flex items-center justify-center active:bg-neutral-600 disabled:opacity-50 text-white"
                                        >
                                            -
                                        </button>
                                        <span className="text-green-500 font-mono text-xl w-6 text-center">{currentChannel}</span>
                                        <button 
                                            disabled={!powerOn}
                                            onClick={() => handleChannelChange(1)}
                                            className="w-10 h-10 bg-neutral-700 rounded-lg flex items-center justify-center active:bg-neutral-600 disabled:opacity-50 text-white"
                                        >
                                            +
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="relative group">
                                <button
                                    disabled={!powerOn}
                                    onMouseDown={startTransmission}
                                    onMouseUp={stopTransmission}
                                    onTouchStart={(e) => { e.preventDefault(); startTransmission(); }}
                                    onTouchEnd={(e) => { e.preventDefault(); stopTransmission(); }}
                                    className={`
                                        w-full py-8 rounded-2xl font-bold text-xl tracking-widest text-white shadow-lg transition-all
                                        border-b-8 active:border-b-0 active:translate-y-2
                                        flex items-center justify-center gap-3
                                        ${powerOn 
                                        ? 'bg-orange-600 border-orange-800 hover:bg-orange-500 cursor-pointer' 
                                        : 'bg-neutral-600 border-neutral-700 cursor-not-allowed opacity-50'}
                                    `}
                                >
                                    <Mic className={`${isTransmitting ? 'animate-pulse' : ''}`} />
                                    <span>{isTransmitting ? 'TRANSMITTING' : 'PUSH TO TALK'}</span>
                                </button>
                                
                                <div className="absolute inset-0 pointer-events-none opacity-10 bg-[url('https://www.transparenttextures.com/patterns/diagmonds-light.png')]"></div>
                            </div>

                            <div className="mt-2 text-center">
                                {!userId ? (
                                    <p className="text-yellow-500 text-xs animate-pulse">Initializing ID...</p>
                                ) : (
                                    <div className="flex items-center justify-center gap-2 text-neutral-500 text-xs">
                                        <Radio size={12} />
                                        <span>ID: {userName}</span>
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="absolute bottom-4 left-4 w-3 h-3 rounded-full bg-neutral-900 border border-neutral-600 flex items-center justify-center">
                            <div className="w-full h-0.5 bg-neutral-700 rotate-45"></div>
                        </div>
                        <div className="absolute bottom-4 right-4 w-3 h-3 rounded-full bg-neutral-900 border border-neutral-600 flex items-center justify-center">
                            <div className="w-full h-0.5 bg-neutral-700 rotate-45"></div>
                        </div>
                    </div>

                    <div className="fixed bottom-4 flex flex-col items-center gap-1 text-neutral-500 text-xs">
                        <p>ចុចប៊ូតុង <span className="text-orange-500 font-bold">PUSH TO TALK</span> ឲ្យជាប់ដើម្បីនិយាយ</p>
                        <div className="flex items-center gap-1">
                            <span>ត្រូវប្រាកដថាបានបើក</span>
                            <Power size={12} className="text-green-500"/>
                            <span>ជាមុនសិន</span>
                        </div>
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
