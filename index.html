<!DOCTYPE html>
<html lang="km">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Khmer Walkie Talkie (Final No Echo)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map for Modules -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1",
        "firebase/app": "https://www.gstatic.com/firebasejs/11.0.2/firebase-app.js",
        "firebase/database": "https://www.gstatic.com/firebasejs/11.0.2/firebase-database.js"
      }
    }
    </script>
    
    <style>
        body {
            background-color: #171717;
            color: white;
            font-family: 'Noto Sans Khmer', sans-serif;
            overscroll-behavior: none;
        }
        ::-webkit-scrollbar {
            display: none;
        }
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { initializeApp } from 'firebase/app';
        import { 
            getDatabase, 
            ref, 
            set, 
            update, 
            push,
            onValue, 
            onChildAdded,
            remove,
            onDisconnect,
            query,
            limitToLast,
            serverTimestamp 
        } from 'firebase/database';
        import { Mic, Radio, Power, Users, Signal } from 'lucide-react';

        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyAcfDALTjrGiD_Te5DyFp7x-F6NrPwqEr4",
            authDomain: "icho-7ddb4.firebaseapp.com",
            databaseURL: "https://icho-7ddb4-default-rtdb.firebaseio.com", 
            projectId: "icho-7ddb4",
            storageBucket: "icho-7ddb4.firebasestorage.app",
            messagingSenderId: "897027326100",
            appId: "1:897027326100:web:a5d726c168a3fc01d23481",
            measurementId: "G-0LPCL7ETRF"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- Constants ---
        const SAMPLE_RATE = 11025; 
        const JITTER_BUFFER_MS = 150; 

        // --- Main App Component ---
        function App() {
            const [userId, setUserId] = useState(null);
            const [powerOn, setPowerOn] = useState(false);
            const [currentChannel, setCurrentChannel] = useState('01');
            const [isTransmitting, setIsTransmitting] = useState(false);
            const [incomingTransmission, setIncomingTransmission] = useState(null); 
            
            // Audio Refs
            const audioContextRef = useRef(null);
            const analyserRef = useRef(null);
            
            // Ref for instant state access inside callbacks
            const isTransmittingRef = useRef(false);
            
            const [userName, setUserName] = useState('');
            
            const canvasRef = useRef(null);
            const processorRef = useRef(null);
            const streamRef = useRef(null);
            const requestRef = useRef(null);
            
            // Audio Scheduling Refs
            const nextStartTimeRef = useRef(0);

            // --- Setup User ID ---
            useEffect(() => {
                let storedId = localStorage.getItem('walkie_user_id');
                if (!storedId) {
                    storedId = 'user_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('walkie_user_id', storedId);
                }
                setUserId(storedId);
                const randomNum = Math.floor(Math.random() * 1000);
                setUserName(`អ្នកប្រើប្រាស់ ${randomNum}`);
            }, []);

            // --- Incoming Status Listener ---
            useEffect(() => {
                if (!userId || !powerOn) return;

                const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                
                const unsubscribe = onValue(statusRef, (snapshot) => {
                    const data = snapshot.val();
                    if (data && data.isActive && data.userId !== userId) {
                        setIncomingTransmission({
                            userId: data.userId,
                            userName: data.userName || 'Unknown'
                        });
                    } else {
                        setIncomingTransmission(null);
                    }
                });

                return () => unsubscribe();
            }, [userId, powerOn, currentChannel]);

            // --- Audio Data Listener (RECEIVER) ---
            useEffect(() => {
                if (!userId || !powerOn) return;

                const audioRef = ref(db, `channels/channel_${currentChannel}/audio_stream`);
                const recentQuery = query(audioRef, limitToLast(1)); 
                
                const unsubscribe = onChildAdded(recentQuery, (snapshot) => {
                    const data = snapshot.val();
                    
                    // CRITICAL FIX: If we are transmitting, DO NOT PLAY anything. 
                    // This enforces Half-Duplex and stops feedback loops.
                    if (isTransmittingRef.current) return;

                    if (data && data.userId !== userId && data.pcmData) {
                         playPCMChunk(data.pcmData);
                    }
                });

                return () => unsubscribe();
            }, [userId, powerOn, currentChannel]);

            // --- Helper: Play Raw PCM Chunk ---
            const playPCMChunk = async (base64Data) => {
                const ctx = audioContextRef.current;
                if (!ctx) return;

                if (ctx.state === 'suspended') {
                    try { await ctx.resume(); } catch(e) {}
                }

                try {
                    // 1. Decode Base64
                    const binaryString = window.atob(base64Data);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const int16Data = new Int16Array(bytes.buffer);

                    // 2. Convert to Float32
                    const float32Data = new Float32Array(int16Data.length);
                    for (let i = 0; i < int16Data.length; i++) {
                        float32Data[i] = int16Data[i] / 32768.0;
                    }

                    // 3. Create Buffer
                    const buffer = ctx.createBuffer(1, float32Data.length, SAMPLE_RATE);
                    buffer.copyToChannel(float32Data, 0);

                    // 4. Schedule
                    const source = ctx.createBufferSource();
                    source.buffer = buffer;
                    source.connect(ctx.destination);

                    const currentTime = ctx.currentTime;
                    const bufferSec = JITTER_BUFFER_MS / 1000;
                    
                    if (nextStartTimeRef.current < currentTime) {
                        nextStartTimeRef.current = currentTime + bufferSec; 
                    }

                    source.start(nextStartTimeRef.current);
                    nextStartTimeRef.current += buffer.duration;

                } catch (err) {
                    console.error("Error playing PCM:", err);
                }
            };

            // --- Visualizer Animation ---
            const animate = () => {
                if (!canvasRef.current || !analyserRef.current) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const analyser = analyserRef.current;
                
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                analyser.getByteFrequencyData(dataArray);

                ctx.fillStyle = '#1f2937'; 
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let barHeight;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i] / 2;
                    ctx.fillStyle = `rgb(50, ${barHeight + 100}, 50)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }

                requestRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                if (isTransmitting && powerOn) {
                    requestRef.current = requestAnimationFrame(animate);
                } else {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                    if (canvasRef.current) {
                        const ctx = canvasRef.current.getContext('2d');
                        ctx.fillStyle = '#1f2937';
                        ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                        ctx.strokeStyle = '#374151';
                        ctx.beginPath();
                        ctx.moveTo(0, canvasRef.current.height / 2);
                        ctx.lineTo(canvasRef.current.width, canvasRef.current.height / 2);
                        ctx.stroke();
                    }
                }
                return () => {
                     if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, [isTransmitting, powerOn]);

            // --- Transmit Logic (SENDER) ---
            const startTransmission = async (e) => {
                if(e) e.preventDefault();
                
                if (!powerOn || !userId || incomingTransmission) return;

                try {
                    const ctx = audioContextRef.current;
                    if (ctx && ctx.state === 'suspended') {
                        await ctx.resume();
                    }

                    // Strict Constraints for Voice
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            googEchoCancellation: true,
                            googAutoGainControl: true,
                            googNoiseSuppression: true,
                            googHighpassFilter: true
                        } 
                    });
                    streamRef.current = stream;
                    
                    const source = ctx.createMediaStreamSource(stream);
                    
                    // Visualizer
                    if (analyserRef.current) {
                        source.connect(analyserRef.current);
                    }

                    const processor = ctx.createScriptProcessor(4096, 1, 1);
                    processorRef.current = processor;

                    // FIX: Connect to a dummy destination to keep processor alive
                    // BUT prevent any audio from reaching the real destination.
                    // This solves the "hearing yourself" problem completely.
                    const dummyDest = ctx.createMediaStreamDestination();
                    
                    source.connect(processor);
                    processor.connect(dummyDest); // Send output to nowhere/dummy

                    processor.onaudioprocess = (e) => {
                        if (!streamRef.current) return;

                        const inputData = e.inputBuffer.getChannelData(0);
                        
                        // Downsample
                        const inputRate = ctx.sampleRate;
                        const ratio = inputRate / SAMPLE_RATE;
                        const downsampledLength = Math.ceil(inputData.length / ratio);
                        const int16Buffer = new Int16Array(downsampledLength);
                        
                        let offset = 0;
                        for (let i = 0; i < inputData.length; i += ratio) {
                            const idx = Math.floor(i);
                            if (idx >= inputData.length) break;
                            let s = Math.max(-1, Math.min(1, inputData[idx]));
                            int16Buffer[offset++] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                        }

                        let binary = '';
                        const bytes = new Uint8Array(int16Buffer.buffer);
                        const len = bytes.byteLength;
                        for (let i = 0; i < len; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        const base64data = window.btoa(binary);

                        const audioRef = ref(db, `channels/channel_${currentChannel}/audio_stream`);
                        push(audioRef, {
                            userId: userId,
                            pcmData: base64data,
                        });
                    };

                    // Sync State
                    setIsTransmitting(true);
                    isTransmittingRef.current = true; // Set ref for immediate check in receiver
                    
                    const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                    onDisconnect(statusRef).update({ isActive: false });
                    await set(statusRef, {
                        isActive: true,
                        userId: userId,
                        userName: userName
                    });

                    // Clear old stream
                    const audioRef = ref(db, `channels/channel_${currentChannel}/audio_stream`);
                    remove(audioRef);

                    playBeep(600, 0.1);

                } catch (err) {
                    console.error("Error accessing mic:", err);
                    alert("សូមអនុញ្ញាតឱ្យប្រើប្រាស់មីក្រូហ្វូន");
                    setIsTransmitting(false);
                    isTransmittingRef.current = false;
                }
            };

            const stopTransmission = async (e) => {
                if(e) e.preventDefault();
                
                if (!isTransmitting) return;

                if (processorRef.current) {
                    processorRef.current.disconnect();
                    processorRef.current.onaudioprocess = null;
                    processorRef.current = null;
                }

                if (streamRef.current) {
                    streamRef.current.getTracks().forEach(track => track.stop());
                    streamRef.current = null;
                }

                setIsTransmitting(false);
                isTransmittingRef.current = false;
                playBeep(400, 0.1);

                const statusRef = ref(db, `channels/channel_${currentChannel}/status`);
                onDisconnect(statusRef).cancel();
                await update(statusRef, { isActive: false });
            };

            // --- Helpers ---
            const playBeep = (freq, duration) => {
                const ctx = audioContextRef.current;
                if (!ctx) return;
                try {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.value = freq;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    osc.start();
                    osc.stop(ctx.currentTime + duration);
                } catch(e) {}
            };

            const handleChannelChange = (delta) => {
                if (!powerOn) return;
                let newCh = parseInt(currentChannel) + delta;
                if (newCh < 1) newCh = 1;
                if (newCh > 99) newCh = 99;
                setCurrentChannel(newCh.toString().padStart(2, '0'));
                playBeep(800, 0.05);
            };

            const togglePower = async (e) => {
                e.stopPropagation();
                
                if (!powerOn) {
                    if (!audioContextRef.current) {
                        const AudioContext = window.AudioContext || window.webkitAudioContext;
                        const ctx = new AudioContext();
                        audioContextRef.current = ctx;
                        
                        const anal = ctx.createAnalyser();
                        anal.fftSize = 256;
                        analyserRef.current = anal;
                        
                        nextStartTimeRef.current = ctx.currentTime;
                    } else if (audioContextRef.current.state === 'suspended') {
                        await audioContextRef.current.resume();
                    }
                    
                    setPowerOn(true);
                    setTimeout(() => playBeep(1000, 0.2), 500);
                } else {
                    if (streamRef.current) {
                        streamRef.current.getTracks().forEach(track => track.stop());
                        streamRef.current = null;
                    }
                    if (processorRef.current) {
                        processorRef.current.disconnect();
                        processorRef.current = null;
                    }
                    setPowerOn(false);
                    isTransmittingRef.current = false;
                    setIsTransmitting(false);
                }
            };

            // --- Render ---
            return (
                <div className="min-h-screen bg-neutral-900 flex items-center justify-center p-4 font-sans no-select overflow-hidden touch-none">
                    <div className="relative w-full max-w-sm bg-neutral-800 rounded-[3rem] shadow-2xl border-4 border-neutral-700 flex flex-col overflow-hidden">
                        
                        <div className="absolute -top-16 right-8 w-6 h-24 bg-neutral-700 rounded-t-lg border-2 border-neutral-600 z-0"></div>
                        <div className="absolute -top-4 left-8 w-3 h-6 bg-red-600 rounded-sm z-0 animate-pulse"></div>

                        <div className="mt-8 mx-auto w-3/4 grid grid-cols-6 gap-1 z-10 opacity-50">
                        {[...Array(24)].map((_, i) => (
                            <div key={i} className="w-1.5 h-1.5 bg-black rounded-full"></div>
                        ))}
                        </div>

                        <div className="mx-6 mt-6 bg-[#9ea792] p-4 rounded-md shadow-inner border-4 border-neutral-600 relative overflow-hidden">
                            <div className="absolute inset-0 bg-green-900 opacity-10 pointer-events-none grid grid-cols-12 gap-px"></div>
                            
                            {powerOn ? (
                                <div className="relative z-10 flex flex-col h-32 justify-between">
                                    <div className="flex justify-between items-center text-xs font-mono font-bold text-neutral-800">
                                        <div className="flex items-center gap-1">
                                            <Signal size={14} />
                                            <span>RX/TX</span>
                                        </div>
                                        <div className="flex items-center gap-1">
                                            <Users size={14} />
                                            <span>CH {currentChannel}</span>
                                        </div>
                                    </div>

                                    <div className="text-center">
                                        {isTransmitting ? (
                                            <div className="text-red-700 font-bold text-lg animate-pulse flex flex-col items-center">
                                                <span>TRANSMITTING</span>
                                                <span className="text-sm">កំពុងនិយាយ...</span>
                                            </div>
                                        ) : incomingTransmission ? (
                                            <div className="text-green-800 font-bold text-lg flex flex-col items-center">
                                                <span>RECEIVING</span>
                                                <span className="text-sm truncate max-w-full">{String(incomingTransmission.userName)}</span>
                                            </div>
                                        ) : (
                                            <div className="text-neutral-600 text-lg font-mono">STANDBY</div>
                                        )}
                                    </div>

                                    <div className="text-4xl font-black font-mono text-center tracking-widest text-neutral-800 opacity-80">
                                        {currentChannel}
                                    </div>
                                </div>
                            ) : (
                                <div className="h-32 flex items-center justify-center text-neutral-400 font-mono text-sm opacity-50">
                                    POWER OFF
                                </div>
                            )}
                        </div>

                        <div className="p-6 flex flex-col gap-6 z-10 bg-neutral-800">
                            
                            <div className="h-16 bg-gray-900 rounded-lg border border-gray-700 overflow-hidden relative shadow-inner">
                                <canvas 
                                    ref={canvasRef} 
                                    width="300" 
                                    height="64" 
                                    className="w-full h-full opacity-80"
                                />
                                <div className="absolute top-1 left-2 text-[10px] text-green-500 font-mono">AUDIO LEVEL</div>
                            </div>

                            <div className="flex justify-between items-center px-2">
                                <button 
                                    onClick={togglePower}
                                    className={`p-4 rounded-full border-b-4 active:border-b-0 active:translate-y-1 transition-all ${powerOn ? 'bg-green-600 border-green-800 text-white shadow-[0_0_15px_rgba(34,197,94,0.5)]' : 'bg-red-600 border-red-800 text-white'}`}
                                >
                                    <Power size={24} />
                                </button>

                                <div className="flex flex-col items-center gap-2 bg-neutral-900 p-2 rounded-xl border border-neutral-700">
                                    <span className="text-[10px] text-gray-400 uppercase tracking-wider">Channel</span>
                                    <div className="flex items-center gap-3">
                                        <button 
                                            disabled={!powerOn}
                                            onClick={() => handleChannelChange(-1)}
                                            className="w-10 h-10 bg-neutral-700 rounded-lg flex items-center justify-center active:bg-neutral-600 disabled:opacity-50 text-white"
                                        >
                                            -
                                        </button>
                                        <span className="text-green-500 font-mono text-xl w-6 text-center">{currentChannel}</span>
                                        <button 
                                            disabled={!powerOn}
                                            onClick={() => handleChannelChange(1)}
                                            className="w-10 h-10 bg-neutral-700 rounded-lg flex items-center justify-center active:bg-neutral-600 disabled:opacity-50 text-white"
                                        >
                                            +
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div className="relative group">
                                <button
                                    disabled={!powerOn}
                                    onMouseDown={startTransmission}
                                    onMouseUp={stopTransmission}
                                    onMouseLeave={stopTransmission}
                                    onTouchStart={startTransmission}
                                    onTouchEnd={stopTransmission}
                                    className={`
                                        w-full py-8 rounded-2xl font-bold text-xl tracking-widest text-white shadow-lg transition-all
                                        border-b-8 active:border-b-0 active:translate-y-2 select-none
                                        flex items-center justify-center gap-3
                                        ${powerOn 
                                        ? 'bg-orange-600 border-orange-800 hover:bg-orange-500 cursor-pointer' 
                                        : 'bg-neutral-600 border-neutral-700 cursor-not-allowed opacity-50'}
                                    `}
                                >
                                    <Mic className={`${isTransmitting ? 'animate-pulse' : ''}`} />
                                    <span>{isTransmitting ? 'TRANSMITTING' : 'PUSH TO TALK'}</span>
                                </button>
                                
                                <div className="absolute inset-0 pointer-events-none opacity-10 bg-[url('https://www.transparenttextures.com/patterns/diagmonds-light.png')]"></div>
                            </div>

                            <div className="mt-2 text-center">
                                {!userId ? (
                                    <p className="text-yellow-500 text-xs animate-pulse">Initializing ID...</p>
                                ) : (
                                    <div className="flex items-center justify-center gap-2 text-neutral-500 text-xs">
                                        <Radio size={12} />
                                        <span>ID: {userName}</span>
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="absolute bottom-4 left-4 w-3 h-3 rounded-full bg-neutral-900 border border-neutral-600 flex items-center justify-center">
                            <div className="w-full h-0.5 bg-neutral-700 rotate-45"></div>
                        </div>
                        <div className="absolute bottom-4 right-4 w-3 h-3 rounded-full bg-neutral-900 border border-neutral-600 flex items-center justify-center">
                            <div className="w-full h-0.5 bg-neutral-700 rotate-45"></div>
                        </div>
                    </div>

                    <div className="fixed bottom-4 flex flex-col items-center gap-1 text-neutral-500 text-xs">
                        <p>ចុចប៊ូតុង <span className="text-orange-500 font-bold">PUSH TO TALK</span> ឲ្យជាប់ដើម្បីនិយាយ</p>
                        <div className="flex items-center gap-1">
                            <span>ត្រូវប្រាកដថាបានបើក</span>
                            <Power size={12} className="text-green-500"/>
                            <span>ជាមុនសិន</span>
                        </div>
                    </div>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
